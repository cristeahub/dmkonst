\section{Introduction}
\label{sec:intro}

``
Introduction: introduces the task of the assignment and the challenges it brings.
Also, it gives a brief introduction to how the task was approached and in which way the solution was reached.
``

A single cycle processor requires each instruction to take exactly one cycle.
This means that each instruction's time is bound by the slowest instruction.

A multi cycle processor requires multiple cycles to execute an instruction.
Because of this the processor is not bound by the slowest instruction.
Complex instructions will use more cycles and still be slow, but less complex instructions will use fewer cycles.
The total time it takes to run less complex, but more common instructions will be lower.

\subsection{Requirements}
\label{subsec:req}
The assignment's main requirement is to make a multi cycle MIPS processor\cite[p.47]{compendium}.
A suggested architecture is given in Figure 4.1 \cite[p.45]{compendium}, which was recommended to use.
Some architectual units were given in the support files, which could be included in the final design.

The following part of the MIPS instruction set is implemented on the FPGA.

\begin{itemize}
    \item ALU instructions (ADD, SUB, SLT, AND, OR)
    \item Conditional Branch (BEZ)
    \item LOAD and STORE (LW, SW)
    \item Load Immediate (LDI)
    \item Jump Instruction (JMP)
\end{itemize}

Note: the {\bf LDI} (Load Immediate) instruction is not a part of the MIPS instruction set\footnote{Figure C.1 \cite[p.66]{compendium}}.
The {\bf LUI} (Load Upper Immediate) is the closest match.
This instruction loads the value into the upper 16 bits of the register.
The support files handed out already used this instruction.

The system is first tested and verified in software, before moving on to testing on hardware.
The testing of the system both in software and in hardware is detailed in section%\vref{sec:testing}.

\subsection{Challenges and procedure}

The assignment provides several tasks that needs solving, these are detailed in section.% TODO: \vref{sec:tasks}.
In addition to the requirements one goal was set for the assignment.
This goal is to make sure all code complies with the standard set forth by the industry
and Xilinx for the Spartan-6 FPGA.
This is to ensure that the generated code will be as optimized as possible,
which in turn will make the processor faster and better.

The assignment is solved by having a top-view of the full extend of the task,
followed by a bottom-up approach to each subtask.
Each component is made separately, with a following testbench to make sure it works correctly.
These components are afterwards connected together and a new testbench is created to
make sure the system as a whole works.
