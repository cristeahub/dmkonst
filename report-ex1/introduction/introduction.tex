\section{Introduction}
\label{sec:intro}

This report presents a solution to exercise \#1 of TDT4255 at NTNU.
The main requirement of the assignment is to make a multi cycle MIPS processor \cite[p.47]{compendium}.
The design should be verified with VHDL testbenches, and finally tested by deploying it to the Xilinx Spartan-6 FPGA.

The suggested architecture for the project is provided in Figure 4.1 \cite[p.45]{compendium},
but has been abandoned in favor of a design based on the basic multi cycle architecture presented in lecture 4 \cite{lecture-4}.

\subsection{Single- and multi cycle processors}

A single cycle processor is able to execute any of its instructions within a single clock period.
This results in simpler hardware, but restricts the processors clock period to the execution time of its slowest instruction.
Disadvantages include having idle datapath elements during some instructions, slow average execution time, and sometimes being required to duplicate execution units.

To work around these issues, the datapath can be partitioned into multiple register-separated elements.
Instructions now require multiple cycles to finish, but simple instructions are no longer bound by the execution time of more complex ones.
This design allows reuse of datapath elements during different execution stages, resulting in a smaller footprint.
Clock speed also increases significantly, as the critical path is reduced to the longest register-separated datapath segment.

\subsection{Challenges and procedure}

The assignment provides several challenges that need solving, in addition to the design of the multi cycle processor itself.

When writing in a HDL for FPGA synthesis, one has to remember that the FPGA is emulating the described hardware with a limited set of specialized hardware resources.
One might for example choose to implement registers as block ram instead of multiplexers with latches, as FPGAs tend to struggle with large multiplexers.
Finally, different synthesis tools have their own quirks and tricks one needs to know about, work with, or around.
Xilinx ISE is no exception.

The assignment is solved by creating a top-level RTL schematic for the processor, which is then subdivided into different components that can be implemented separately.
A testbench is written for each component, to ensure correct functionality.
These components are afterwards connected together and new testbenches are created to make sure the system as a whole works according to specification.

After the system has been tested and verified in software, testing moves on to hardware.
