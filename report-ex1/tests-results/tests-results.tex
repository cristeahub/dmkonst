\section{Tests and Results}

% Results: presents the results: what has been successfully completed and what did not work.
% If any ways around it were found, provide them at this place. Every solution should be tested for its validity.
% This is the place where you will describe what kind of testing you have performed and what the outcome of your tests was.

\subsection{Performance}

Is it fast yet?

\subsection{Energy efficiency}

How much power does it consume when running on the FPGA?

\subsection{Testbenches}

% TODO: some parts of this might be better suited for solution or discussion?
All tests are written in VHDL and simulated in ISim.
Each component has been tested and verified with a separate testbench.
The system as a whole has also been tested with a separate testbech.
The mindset for the testbenches is to not only provide valuable testing to see if the compontents work,
but also make sure to give valueable feedback to the programmer.

The results of the tests are shown in table \ref{tab:tests}.

\begin{table}[ht+]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Test name}            & \textbf{Pass?} & \textbf{Notes}            \\ \hline
        tb\_MIPSProcessor.vhd         & Passed         & Integrated machinery test \\ \hline
        tb\_alu.vhd                   & Passed         & Unit test                 \\ \hline
        tb\_control\_unit.vhd         & Passed         & Unit test                 \\ \hline
        tb\_instruction\_register.vhd & Passed         & Unit test                 \\ \hline
        tb\_mux.vhd                   & Passed         & Unit test                 \\ \hline
        tb\_mux\_4.vhd                & Passed         & Unit test                 \\ \hline
        tb\_pc.vhd                    & Passed         & Unit test                 \\ \hline
        tb\_registers.vhd             & Passed         & Unit test                 \\ \hline
        tb\_shift\_left\_2.vhd        & Passed         & Unit test                 \\ \hline
        tb\_sign\_extend.vhd          & Passed         & Unit test                 \\ \hline
    \end{tabular}
    \caption{Tests being performed on the processor}
    \label{tab:tests}
\end{table}

\begin{figure}[ht!]
    \begin{center}
    \includegraphics[width=\textwidth]{assets/isim/memory_read_cycle.png}
    \caption{Snapshot of the top level testbench when executing a load instruction}
    \label{fig:memory_read_cycle}
    \end{center}
\end{figure}

\begin{figure}[ht!]
    \begin{center}
    \includegraphics[width=\textwidth]{assets/isim/branch_completion_cycle.png}
    \caption{Snapshot of the top level testbench when running a branch instruction}
    \label{fig:branch_completion_cycle}
    \end{center}
\end{figure}

\begin{figure}[ht!]
    \begin{center}
    \includegraphics[width=\textwidth]{assets/isim/load_upper_cycle.png}
    \caption{Execution of a load immediate, where the value 393216 is stored in register 3}
    \label{fig:load_upper_cycle}
    \end{center}
\end{figure}

\begin{figure}[ht!]
    \begin{center}
    \includegraphics[width=\textwidth]{assets/isim/r_type_cycle.png}
    \caption{An r-type instruction with ALU op set to ADD}
    \label{fig:r_type_cycle}
    \end{center}
\end{figure}

\subsection{Testing on hardware}

% TODO: a series of steps need to be taken?
When testing on the actual hardware, a series of steps needs to be taken.
These steps are illustrated in figure \ref{fig:testing_on_fpga}.

Firstly a .bit file must be generated form Xilinx.
This file is then uploaded to the FPGA via the hostcomm utility.
Afterwards a simple program is made, or taken from the testbench for the processor.

The endianness of the hostcomm utility \cite{hostcomm} is different from the testbench.
Because of that a simple translator was written in python to change
the endianness of the sample program \cite{endian-change}.
This program made it possible to paste its output straight into hostcomm.

With the program in the hostcomm utility, one can upload it to the fpga.
A button in hostcomm runs the program and afterwards there is a possibility to read form the FPGA memory.

The content of the FPGA memory is then verified against expected output manually.

\begin{figure}[ht!]
    \begin{center}
        \subfigure[Generate .bit file from Xilinx]{%
            \label{fig:generate_fpga}
            \includegraphics[width=0.4\textwidth]{assets/testing_on_fpga/generate_programming_file.JPG}
        }%
        \subfigure[Upload .bit file to the FPGA]{%
            \label{fig:processor_upload_fpga}
            \includegraphics[width=0.4\textwidth]{assets/testing_on_fpga/uploaded_successfully.JPG}
        }\\ %  ------- End of the first row ----------------------%
        \subfigure[Change endianness]{%
            \label{fig:endinanness_fpga}
            \includegraphics[width=0.4\textwidth]{assets/testing_on_fpga/change_endianness.JPG}
        }%
        \subfigure[Upload program to FPGA]{%
            \label{fig:program_upload_fpga}
            \includegraphics[width=0.4\textwidth]{assets/testing_on_fpga/upload_program_to_fpga.JPG}
        }\\ %%  ------- End of the second row ----------------------%
        \subfigure[Run program on FPGA]{%
            \label{fig:run_on_fpga}
            \includegraphics[width=0.4\textwidth]{assets/testing_on_fpga/run_on_fpga.JPG}
        }%
        \subfigure[Read data from FPGA]{%
            \label{fig:data_read_fpga}
            \includegraphics[width=0.4\textwidth]{assets/testing_on_fpga/data_read_from_fpga.JPG}
        }%
    \end{center}
    \caption{%
    Testing design on the FPGA in six simple steps.
    }%
    \label{fig:testing_on_fpga}
\end{figure}
