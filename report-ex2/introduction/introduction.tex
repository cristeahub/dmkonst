\chapter{Introduction}

\section{Assignment}
The major requirement of the assignment is to implement a simple 5-stage pipelined processor.
The functional requirements are mostly the same as in assignment 1\cite[p.44]{compendium}, however, some additional features are needed to detect and correct different hazards.
Therefore, the solution to this assignment is heavily based on our solution to the previous assignment\cite{report-1}.

The implemented architecture is based on the one provided in Figure 5.1 \cite[p.50]{compendium},
and extended based on sections 4.7 and 4.8 in \cite{thebook}.

\section{Pipelined processors}

A pipelined processor differs from simple single- and multi-cycle processors in that multiple instructions may be in different parts of execution in the same clock cycle.
In the simple MIPS pipeline, one will be fetched, one decoded, one executed, one doing memory operations, and one writing values back to registers.
This overlaying allows the pipelined processor to utilize almost all parts of the data path at the same time, as opposed to the multi cycle implementation.
Having up to five instructions execute at once can provide a speed-up of almost 4 times on large programs \cite[p.276]{thebook}.

Pipelining does not come without a cost, as a family of pipeline hazards appear.
Data hazards appear when an instruction requires an operand generated by the instructions preceding it.
Control hazards originate from branch and other control flow instructions.
Normal pipeline operation cannot continue, as the instructions following the branch might not require execution.
Structural hazards appear when an instruction has to wait for some hardware unit to become available.
Left untreated, these hazards will require frequent stalling of the pipeline, inserting nops.
A proper solution includes adding advanced hardware elements to preform operand forwarding when necessary, predicting branches when required, and stalling the pipeline when no solution can be found.

\section{Procedure}

We decided to tackle this assignment in a gradual manner.
We set a goal to first convert the multi-cycle processor into a pipelined one, by introducing barriers and making a minimum set of changes needed to keep it functional.
A modified version of the provided top level test, with a generous amount of nops inserted to avoid data and control hazards, would confirm that this transformation was successful.
The next goal was to add hazard detection and data forwarding, eliminating programmer-inserted nops in the source code.
A final goal was set to support dynamic branch prediction, and thereby increasing the performance of the processor by having to flush the pipeline less often.
