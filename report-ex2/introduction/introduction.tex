\chapter{Introduction}

\section{Assignment}
The major requirement of the assignment is to implement a simple 5-stage pipelined processor.
The functional requirements are mostly the same as in assignment 1\cite[p.44]{compendium}, however, some additional features are needed to detect and correct different pipeline hazards.
Therefore, the solution to this assignment is heavily based on our solution to the previous assignment\cite{report-1}.

The implemented architecture is based on the one provided in Figure 5.1 \cite[p.50]{compendium},
and extended based on sections 4.7 and 4.8 in \cite{thebook}.

\section{Pipelined processors}

A pipelined processor differs from simple single- and multi-cycle processors in that multiple instructions may be in execution at the same time, in different parts of the datapath.
This overlaying allows the pipelined processor to utilize almost all parts of the data path at the same time, as opposed to the multi cycle implementation.
Having up to five instructions execute at once (as in the MIPS architecture) can provide a speed-up of almost 4 times on large programs \cite[p.276]{thebook}.

Pipelining introduces new problems: pipeline hazards.
Data hazards appear when an instruction requires operands generated by earlier instructions still in the pipeline.
Branch instructions cause control hazards, as new instructions cannot be fetched until the branch is decided.
These hazards require frequent stalling of the pipeline, when left untreated.
A proper solution adds dedicated hardware to forward operands, predict branches and automatically stalling the pipeline when needed.

\section{Procedure}

The assignment was tackled in a gradual manner.
We set a goal to first convert the multi-cycle processor into a pipelined one, by introducing barriers and making a minimum set of changes needed to keep it functional.
A modified version of the provided top level test, with a generous amount of nops inserted to avoid data and control hazards, would confirm that this transformation was successful.
The next goal was to add hazard detection and data forwarding, eliminating programmer-inserted nops in the source code.
A final goal was set to support dynamic branch prediction, and thereby increasing the performance of the processor by having to flush the pipeline less often.
