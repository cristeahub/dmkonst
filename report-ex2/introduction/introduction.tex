\chapter{Introduction}

\section{Assignment}
The major requirement of the assignment is to implement a simple 5-stage pipelined processor.
The functional requirements are mostly the same as in assignment 1\cite[p.44]{compendium}, however, some additional features are needed to detect and correct different hazards.
Therefore, the solution to this assignment is heavily based on our solution to the previous assignment\cite{report-1}.

The implemented architecture is based on the one provided in Figure 5.1 \cite[p.50]{compendium},
and extended based on sections 4.7 and 4.8 in \cite{thebook}.

\section{Pipelined processors}

A pipelined processor differs from simple single- and multi-cycle processors by executing multiple instructions at the same time.
It extends on the multi-cycle architecture in that an instruction goes through different stages of the processor.\todo{This sentence just suddenly ends!}
The difference is that while in the multi-cycle processor parts of the hardware is unused at most times, the pipelined processor tries to utilize all parts of the processor at all times.
When an instruction progresses from the instruction fetch stage to the decode stage, a new instruction can be fetched at the same time. And when one instruction is in the execute stage, another one can be writing to data memory.
Having up to five instructions execute at once can provide a speed-up of almost 4 times on large programs \cite[p.276]{thebook}.

\section{Procedure}

We decided to tackle this assignment in a gradual manner.
We set a goal to first convert the multi-cycle processor into a pipelined one, by introducing barriers and making a minimum set of changes needed to keep it functional.
A modified version of the provided top level test, with a generous amount of nops inserted to avoid data and control hazards, would confirm that this transformation was successful.
The next goal was to add hazard detection and data forwarding, and thus not needing programmer-inserted nops in the source code.
A final goal was set to support dynamic branch prediction, and thereby increasing the performance of the processor by having to flush the pipeline less often.
