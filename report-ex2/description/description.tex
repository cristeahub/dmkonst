\section{Description}

Søndag:

\begin{enumerate}
  \item Our methodology: Rewrite system from Ex1 to use barriers, and combinatorial state.
  \item Extend RTL sketch from book with support for 2-cycle jumps.
  \item Test that the entire program works, simulating a multicycle architecture with the pipelined version by filling pipeline with nops after each 'real' instruction.
  \item Everything now works in the ghettoPipeline. Many issues were had with the assembler, as no testing suite was developed. Bugs had to be ironed out manually.
\end{enumerate}

Optimization: Move branch one step earlier. Might introduce longer critical path.
Delays: 4 nops on data dependencies. 3 nops on branch. 1 nop on jump.


yo peeps. (dette er kanskje discussion-mat)
trade-off:

forwarding fra ex/mem fra branch calculation, vs. ingen forwarding med mer branch prediction

For at forwarding skal ha noen særlig effekt, må man ha en nop før branch, fordi man ikke kan forwarde fra ex stage.
Siden man oftest brancher i loops, vil én ekstra overhead per branch calculation, være mye dyrere enn en potensiell 0/2-sykel delay ved korrekt/feil gjett i predictoren.
Heldigvis vil en to-bit prediktor være svært nøyaktig i en loop, da den raskt vil korrigere seg inn.
Den kan worst-case starte med to feil, det gir fire sykler delay.
Altså for loops med flere enn fire iterasjoner vil det lønne seg med prediktor, og uten forwarding.

PS: forwarding kan også introdusere en lengre kritisk sti, og redusere klokkehastigheten.
