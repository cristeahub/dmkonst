\section{Description}

Some description

Søndag:

\begin{enumerate}
  \item Our methodology: Rewrite system from Ex1 to use barriers, and combinatorial state.
  \item Extend RTL sketch from book with support for 2-cycle jumps.
  \item Test that the entire program works, simulating a multicycle architecture with the pipelined version by filling pipeline with nops after each 'real' instruction.
  \item Everything now works in the ghettoPipeline. Many issues were had with the assembler, as no testing suite was developed. Bugs had to be ironed out manually.
\end{enumerate}

Optimization: Move branch one step earlier. Might introduce longer critical path.
Delays: 4 nops on data dependencies. 3 nops on branch. 1 nop on jump.


Mandag - Christoffer:
Gikk igjennom hele RTL-en sakte og sikkert
\begin{enumerate}
    \item - Why does the shamt from IF/ID go straight to ALU\_CTRL in the RTL? Shouldn't it go to the ID/EX mem?
    \item - The RTL I started with looked a lot like the one in the compendium, but JMP isn't included there.
    A small intro to what parts make up the JMP would be awesome.
\end{enumerate}

Forwarding unit is a relatively easy component.
It's suppose to make a hotwire connection between a calculated value and where that value is needed.
Because it avoids writing to registers, up to several cycles can be saved.

The way this works is to have a unit that checks if the current calculated value's address in memory
is equal to that of the RD or RT of the next instruction.
If it is, a mux connecting the newly calculated value is changed to let the newly calculated value thru.

The forwarding unit recieved addresses as input, as well as a write signal from both
the EX/MEM and MEM/WB registers.
It releases control signals to the muxes that switch the input to the ALU.
These muxes are now extended to also get the immidiate value from both EX/MEM and MEM/WB.

After recieving the values the forwarding unit checks if the values just made should be used for the next
caclucations.
If yes, it gives the apropriate signals to the mux.


TODO: on the forwarding unit.

Add muxes to the input for the ALU.
These are muxes with 3 inputs and 1 control signal.
The control signals shall come from the forwarding unit, namely `forward\_rd\_out` and `forward\_rt\_out`.
The three values from the muxes are wires from the following places:
- read\_data\_X\_out which already goes to the ALU
- write\_data\_mux\_out from the mux after storage mem/wb
- alu\_result\_out from storage ex/mem

Connect the following wires to the forwarding unit:
- write\_register\_out from storage ex/mem
- wb signal from storage ex/mem
- write\_register\_out from storage mem/wb
- wb signal from mem/wb
- read\_register\_1\_in which goes to the register.vhd file needs to be saved to IF/EX storage
and then given to the forwarding unit
- read\_register\_2\_in which goes to the register.vhd file needs to be saved to IF/EX storage
and then given to the forwarding unit

That should be it :)

yo peeps. (dette er kanskje discussion-mat)
trade-off:

forwarding fra ex/mem fra branch calculation, vs. ingen forwarding med mer branch prediction

For at forwarding skal ha noen særlig effekt, må man ha en nop før branch, fordi man ikke kan forwarde fra ex stage.
Siden man oftest brancher i loops, vil én ekstra overhead per branch calculation, være mye dyrere enn en potensiell 0/2-sykel delay ved korrekt/feil gjett i predictoren.
Heldigvis vil en to-bit prediktor være svært nøyaktig i en loop, da den raskt vil korrigere seg inn.
Den kan worst-case starte med to feil, det gir fire sykler delay.
Altså for loops med flere enn fire iterasjoner vil det lønne seg med prediktor, og uten forwarding.

PS: forwarding kan også introdusere en lengre kritisk sti, og redusere klokkehastigheten.
